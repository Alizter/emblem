#!/usr/bin/python3
# Copyright (C) Edward Jones
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
from os.path import basename, dirname, relpath
from sys import argv, exit, stderr
from yaml import FullLoader, load
from functools import reduce


DESC_INDENT:int = 25
DESC_MIN_MARGIN:int = 4


def parser_gens() -> dict:
    return {'c': gen_c}


def main(args: [str]) -> int:
    lang: str = get_lang(args)
    ifname: str = get_ifname(args)

    inp: dict
    with open('/dev/stdin', 'r') as i:
        inp = load(i, Loader=FullLoader)

    if not sanitise_args(inp):
        return 1

    parser: [(str, str)] = gen_parser(inp, lang, ifname if ifname != '-' else 'argp_stdout')
    for (ofname, frag) in parser:
        if ifname == '-':
            print(frag)
        else:
            with open(ofname, 'w+') as of:
                print(frag, file=of)
    return 0


def get_lang(args: [str]) -> str:
    langs: [str] = list(filter(lambda a: a.startswith('-x'), args))
    if len(langs) != 1:
        print(f'{argv[0]}: Please pass exactly one -xLANG argument',
              file=stderr)
        exit(1)
    else:
        return langs[0][2:]


def get_ifname(args: [str]) -> str:
    ifnames: [str] = list(
        filter(lambda a: a == '-' or not a.startswith('-'), args))
    if len(ifnames) > 1:
        print(f'{argv[0]}: Please pass at most one output file stem')
        exit(1)
    else:
        return ifnames[0] if len(ifnames) else 'argp'


def sanitise_args(spec) -> bool:
    if spec == None:
        print('Please give a YAML specification through stdin', file=stderr)
        return False
    ret:bool = True
    defaults:dict = {
            'mandatory': lambda _: False,
            'type': lambda a: 'flag' if ('short' in a or 'long' in a) and ('positional' not in a or not a['positional']) else 'char*',
            'default': lambda a: 0 if 'type' not in a or a['type'] != 'char*' else '""',
            'help': lambda _: '',
            'positional': lambda a: 'short' not in a and 'long' not in a,
            'metaDest': lambda a: a['dest'] if 'dest' in a else 'UNKNOWN',
            'gobble': lambda _: False
        }
    required:[str] = ['dest']
    for arg in spec['args']:
        argName:str = arg['short'] if 'short' in arg else (arg['long'] if 'long' in arg else 'UN-NAMED ARGUMENT')
        for req in required:
            if type(req) == str:
                req = [req]
            hasSomeReq:bool = False
            for req2 in req:
                if req2 in arg:
                    hasSomeReq = True
                    break
            if not hasSomeReq:
                print('Missing argument %s in %s definition' %(' or '.join(req), argName), file=stderr)
                ret = False
        for key in defaults.keys():
            if key not in arg:
                arg[key] = defaults[key](arg)

    numGobblers:int = len(list(filter(lambda a: a['gobble'], spec['args'])))
    if numGobblers not in [0, 1]:
        print('Too many gobbling arguments in the spec (%d of them), only one is supported' % numGobblers, file=stderr)
        ret = False
    if numGobblers != 0 and list(filter(lambda a: a['gobble'], spec['args']))[0]['mandatory'] and len(list(filter(lambda a: not a['mandatory'] and a['positional'], spec['args']))) != 0:
        print('Mandatory gobbling arguments with non-mandatory positional arguments is not supported', file=stderr)
        ret = False

    if list(filter(lambda a: a['type'] == 'help', spec['args'])) == []:
        spec['args'] += [{ 'type': 'help', 'short': '-h', 'long': '--help', 'help': 'display this help message and exit', 'mandatory': False, 'positional': False, 'gobble': False }]

    spec['args'] = list(sorted(spec['args'], key=lambda a: (a['positional'], a['mandatory'], a['gobble'])))

    return ret


def gen_parser(inp: dict, lang: str, ifname: str) -> [(str, str)]:
    pgens = parser_gens()
    if lang in pgens:
        return pgens[lang](inp, ifname)
    else:
        print('%s: Unknown language \'%s\'' % (argv[0], lang), file=stderr)
        exit(1)


def gen_c(spec: dict, ifname: str) -> [(str, str)]:
    hdrfl:str = ifname + '.h'
    prsrfl:str = ifname + '.c'
    hdrfl_rel:str = basename(hdrfl)
    ifname_sanitised:str = ifname.replace('.', '_').replace('/', '__')

    args:dict = spec['args']
    numGobbledDef:[dict] = [{ 'type': 'int', 'dest': 'numGobbled', 'gobble': False, 'default': 0, 'doc': 'Holds the number of arguments gobbled' }] if len(list(filter(lambda a: a['gobble'], args))) > 0 else []

    opt_decls:str = '\n'.join(list(map(lambda a: ('/**\n * @brief %s\n */\n' %a['doc'] if 'doc' in a else '') + '%s %s;' %(a['type'] + '*' if a['gobble'] else a['type'].replace('flag','int'), a['dest']), list(filter(lambda a : a['type'] != 'help', args + numGobbledDef)))))
    header: str = '\n'.join([
        '#ifndef %s_H_' % ifname_sanitised.upper(),
        '#define %s_H_' % ifname_sanitised.upper(),
        '',
        opt_decls,
        '',
        '/**',
        ' * @brief Parse command-line arguments and assign to appropriate globals',
        ' *',
        ' * @param argc Number of command-line arguments',
        ' * @param argv Pointer to start of command-line arguments',
        ' *',
        ' * @return 0 for success, 1 for failure, -1 for success but an immediate exit is advised (e.g. --help)',
        ' */',
        'int parse_args(int argc, char** argv);',
        '',
        '#endif /* %s_H_ */' % ifname_sanitised.upper(),
    ])

    mandatoryArgs:[dict] = list(filter(lambda a: a['mandatory'], args))
    mandatoryFlags:[str] = [] if mandatoryArgs == [] else ['int %s;' % ', '.join(list(map(lambda d: f'is_set__{d["dest"]} = 0', list(filter(lambda a: a['mandatory'], args)))))]

    def assignment_handler(arg:dict) -> [str]:
        asignand:str
        asignarg:str
        mandarg:[str] = []
        freearg:[str] = []
        if arg['type'] == 'help':
            asignand = 'showHelp'
        else:
            asignand = arg['dest']

        if arg['type'] in [ 'help', 'flag' ]:
            asignarg = 1
        else:
            if arg['type'] == 'char*':
                freearg = [f'free({arg["dest"]});']
            asignarg = 'strdup(optarg)' if arg['type'] == 'char*' else 'atoi(optarg)'

        if arg['mandatory']:
            mandarg = ['is_set__%s = 1;' % arg['dest']]

        return freearg + [ f'{asignand} = {asignarg};'] + mandarg +['break;']

    opts_short:str = ''.join(list(map(lambda arg: arg['short'][1] + ('' if arg['type'] in ['flag', 'help'] else ':'), list(filter(lambda a: not a['positional'] and 'short' in a, args)))))
    opts_long:str = ', '.join(list(map(lambda a: '{ "%s", %d, NULL, \'%s\' }' %(a['long'][2:], 1 if a['type'] not in ['flag', 'help'] else 0, a['short'][1]), list(filter(lambda a: not a['positional'] and 'long' in a, args)))) + [ '{ NULL, 0, NULL, 0 }' ])
    def default_val(arg:dict) -> str:
        if arg['gobble']:
            return 'NULL'
        elif arg['type'] == 'char*':
            return 'strdup("%s")' % arg['default']
        else:
            return str(arg['default'])
    defaults:[str] = list(map(lambda arg: '%s = %s;' %(arg['dest'], default_val(arg)), list(filter(lambda arg: arg['type'] != 'help', args + numGobbledDef))))
    opt_handlers:list = list(reduce(lambda a,b: a+b, list(map(lambda a: ["case '%s':" % a['short'][1], assignment_handler(a)], list(filter(lambda a: not a['positional'], args))))))

    def arg_usage(arg:dict, isShort:bool) -> str:
        if isShort and 'short' not in arg or not isShort and 'long' not in arg:
            return ''
        out = arg['short' if isShort else 'long']
        if 'choices' in arg:
            out = out + ('=' if not isShort else '') + ('{' + ', '.join(list(map(str, arg['choices']))) + '}')
        elif 'metaDest' in arg and arg['type'] not in ['flag', 'help']:
            out = out + ('=' if not isShort else '') + arg['metaDest'].upper()
        elif arg['positional']:
            out = arg['metaDest'].upper()
        return out if arg['mandatory'] else '[' + out + ']'
    usage_string:str = 'Usage: %s ' + ' '.join(list(map(lambda a: arg_usage(a, True), args))) + '\\n'
    def arg_desc(arg:dict) -> str:
        inv:str
        if arg['positional']:
            inv = arg['metaDest'].upper() + ('...' if arg['gobble'] else '')
        else:
            inv = ', '.join([arg_usage(arg, True), arg_usage(arg, False)])
        if len(inv) >= DESC_INDENT + DESC_MIN_MARGIN - 2:
            return '  ' + inv + '\\n' + ' ' * (DESC_MIN_MARGIN + DESC_INDENT) + arg['help']
        else:
            return '  ' + inv.ljust(DESC_MIN_MARGIN + DESC_INDENT - 2, ' ') + arg['help']

    help_printer:[str] = list(map(lambda s: 'fprintf(stderr, "%s\\n");' %s, list(map(arg_desc, args))))

    positionalArgs:[dict] = list(filter(lambda a: a['positional'], args))
    posIssetPtrs:str = 'int* issets[] = { %s };' % ', '.join(list(map(lambda a: f'&is_set__{a["dest"]}', list(filter(lambda a: a['mandatory'], positionalArgs)))))
    posValPtrs:str = 'char** posargs[] = { %s };' % ', '.join(list(map(lambda a: f'&{a["dest"]}', sorted(list(filter(lambda a: not a['gobble'], positionalArgs)), key=lambda a: not a['mandatory']))))
    gobbleHandler:[str]
    gobblers:[dict] = list(filter(lambda a: a['gobble'], positionalArgs))
    gobbler:dict = gobblers[0] if gobblers != [] else None
    if len(gobblers) == 1:
        gobbleHandler = [
                'numGobbled = argc - pospos__;',
                '%s = calloc(numGobbled, sizeof(%s));' %(gobbler['dest'], gobbler['type']),
                'for(int i = 0; i < numGobbled; i++)', '{', [
                    '%s[i] = %s;' %(gobbler['dest'], 'strdup(argv[pospos__ + i])' if gobbler['type'] == 'char*' else 'atoi(argv[pospos__ + i])')
                ], '}'
            ]
    else:
        gobbleHandler = [
                'fprintf(stderr, "Too many positional arguments passed\\n");',
                'showUsage = 1;'
            ]

    positionalArgNum:int = len(list(filter(lambda a: a['positional'], args)))
    positionalHandler:list = [
            posIssetPtrs,
            'const int numIssets = sizeof(issets)/sizeof(*issets);',
            posValPtrs,
            'const int numPosargs = sizeof(posargs)/sizeof(*posargs);',
            'int pospos__;',
            'for (pospos__ = 0; pospos__ < argc - optind && pospos__ < numPosargs; pospos__++)', '{', [
                'if (pospos__ < numIssets)', '{', [
                    '*issets[pospos__] = 1;',
                ], '}',
                'free((void*)*posargs[pospos__]);',
                '*posargs[pospos__] = strdup(argv[pospos__ + optind]);'
            ], '}',
            'if (pospos__ == numPosargs && pospos__ < argc - optind)',  '{', gobbleHandler, '}'
        ]

    def validate_arg(arg:dict) -> [str]:
        vdr:[str] = []
        if arg['mandatory']:
            vdr += [
                    'if (!is_set__%s)' % arg['dest'],
                    '{', [
                        'fprintf(stderr, "%%s: Missing argument: %s\\n", argv[0]);' % (arg['short'] if not arg['positional'] else arg['metaDest'].upper()),
                        'showUsage = 1;',
                    ], '}'
                ]
        if 'choices' in arg:
            vdr += [
                    'if (%s)' % ' && '.join(list(map(lambda c: ('strcmp(%s, "%s")' if arg['type'] == 'char*' else '%s != %s') % (arg['dest'], c), arg['choices']))) ,
                    '{', [
                        'fprintf(stderr, "%%s: Value %s not allowed for argument %s\\n", argv[0], %s);' %('%s' if arg['type'] == 'char*' else '%d', arg['short'], arg['dest']),
                        'showUsage = 1;'
                     ],'}'
                ]
        return vdr
    validator:[str] = list(reduce(lambda a,b: a+b, list(filter(lambda v: v != [], list(map(validate_arg, args))))))

    gobblerDestructor:[str] = [ 'for (int i = 0; i < numGobbled; i++)', '{', [ 'free(%s[i]);' % gobbler['dest'] ], '}', 'free(%s);' % gobbler['dest'] ] if gobblers != [] else []
    destructor:[str] = list(map(lambda a: 'free(%s);' % a['dest'], list(filter(lambda a: not a['gobble'] and a['type'] == 'char*', args)))) + gobblerDestructor

    parser_body: str = indent([
        '#include "%s"' % hdrfl_rel,
        '',
        '#include <getopt.h>',
        '#include <stdio.h>',
        '#include <stdlib.h>',
        '#include <string.h>',
        '',
        '/**',
        '* @brief Short getopt command-line parameter declaration',
        '*/',
        '#define SHORT_OPTS "%s"' % opts_short,
        '',
        '/**',
        '* @brief Long getopt command-line parameter declaration',
        '*/',
        'static struct option long_opts[] = { %s };' % opts_long,
        '',
        'static void init(void) __attribute__((constructor));',
        'static void fini(void) __attribute__((destructor));',
        '',
        '/**',
        '* @brief Set initial argument values',
        '*/',
        'static void init(void)', '{', defaults, '}',
        '',
        'int parse_args(int argc, char** argv)', '{', mandatoryFlags + [
            'int optc;',
            'int showUsage = 0, showHelp = 0;',
            'while ((optc = getopt_long(argc, argv, SHORT_OPTS, long_opts, NULL)) != -1)', '{', [
                'switch (optc)', '{', opt_handlers + [
                    'default:', [
                        'showUsage = 1;',
                        'break;'
                    ]
                ], '}'
            ], '}',
            '',
        ] + positionalHandler + validator + [
            '',
            'if (showUsage)', '{', [
                'fprintf(stderr, "%s", argv[0]);' % usage_string,
                'return 1;'
            ], '}',
            'else if (showHelp)', '{', [
                'fprintf(stderr, "%s", argv[0]);' % usage_string,
            ] + help_printer + [
                'return -1;',
            ], '}',
            '',
            'return 0;'
        ], '}',
        '',
        '/**',
        '* @brief Clean up argument memory',
        '*/',
        'static void fini(void)', '{', destructor, '}'
    ])

    return [(hdrfl, header), (prsrfl, parser_body)]


def indent(lst: list) -> str:
    def _indent(lst: list, lvl: int, fst:bool) -> str:
        if type(lst) == str:
            return lst
        else:
            ind = '\t' * lvl
            return ('\t' if not fst else '') + ('\n%s' % ind).join(
                list(map(lambda e: _indent(e, lvl + 1, False), lst)))

    return _indent(lst, 0, True)


if __name__ == '__main__':
    try:
        exit(main(argv[1:]))
    except KeyboardInterrupt as ke:
        print(ke, file=stderr)
        exit(1)
