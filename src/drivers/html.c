#include "html.h"

#include "data/cmp.h"
#include "data/hash.h"
#include "data/list.h"
#include "data/map.h"
#include "logs/logs.h"
#include "write-out.h"
#include <errno.h>
#include <stdarg.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

typedef struct
{
	List* content;
	List* formatter_content;
	Str* output_doc_name;
	Str* stylesheet_name;
	Str* time_str;
	Map* call_name_map;
} HtmlFormatter;

static void make_html_formatter(HtmlFormatter* formatter, DriverParams* params);
static void dest_html_formatter(HtmlFormatter* formatter);
static int driver_runner(Doc* doc, DriverParams* params);
static int output_stylesheet(HtmlFormatter* formatter, List* css_snippets);
static int format_doc_as_html(HtmlFormatter* formatter, Doc* doc);
static void get_time_str(Str* time_str);
static void append_raw(HtmlFormatter* formatter, char* raw);
static void append_str(HtmlFormatter* formatter, Str* str);
static void append_strf(HtmlFormatter* formatter, char* restrict format, ...) __attribute__((format(printf, 2, 3)));
static int format_node_as_html(HtmlFormatter* formatter, DocTreeNode* node);
static int format_node_list_as_html(HtmlFormatter* formatter, List* node_list);

#define HTML_HEADER                                                                                                    \
	"<!DOCTYPE html>\n"                                                                                                \
	"<!-- This file was generated by `em` on %s. -->\n"                                                                \
	"<!-- Any changes will be overwritten next time typesetting is run -->\n"
#define STYLESHEET_HEADER                                                                                              \
	"/*\n"                                                                                                             \
	" * This file was generated by `em` on %s.\n"                                                                      \
	" * Any changes will be overwritten next time typesetting is run.\n"                                               \
	" */\n"
#define STYLESHEET_LINK			 "<link rel=\"stylesheet\" type=\"text/css\" href=\"%s\">"
#define TITLE_DEF				 "<title>%s</title>"
#define STYLESHEET_NAME_FMT		 "%s.css"
#define DOCUMENT_OUTPUT_NAME_FMT "%s.html"

int make_html_driver(InternalDriver* driver)
{
	OutputDriverInf* driver_inf		 = malloc(sizeof(OutputDriverInf));
	driver_inf->supports_typesetting = false,

	driver->name = "html";
	driver->inf	 = driver_inf;
	driver->run	 = driver_runner;

	return 0;
}

static void make_html_formatter(HtmlFormatter* formatter, DriverParams* params)
{
	formatter->time_str = malloc(sizeof(Str));
	get_time_str(formatter->time_str);

	// Compute the name of the outputted document
	size_t output_doc_name_len = params->output_stem->len + sizeof(DOCUMENT_OUTPUT_NAME_FMT);
	char* output_doc_name_raw  = malloc(output_doc_name_len);
	snprintf(output_doc_name_raw, output_doc_name_len + 1, DOCUMENT_OUTPUT_NAME_FMT, params->output_stem->str);
	formatter->output_doc_name = malloc(sizeof(Str));
	make_strr(formatter->output_doc_name, output_doc_name_raw);

	// Compute the name of the stylesheet file
	size_t stylesheet_name_len = params->output_stem->len + sizeof(STYLESHEET_NAME_FMT);
	char* stylesheet_name	   = malloc(stylesheet_name_len);
	snprintf(stylesheet_name, stylesheet_name_len + 1, STYLESHEET_NAME_FMT, params->output_stem->str);
	formatter->stylesheet_name = malloc(sizeof(Str));
	make_strr(formatter->stylesheet_name, stylesheet_name);

	formatter->content = malloc(sizeof(List));
	make_list(formatter->content);
	formatter->formatter_content = malloc(sizeof(List));
	make_list(formatter->formatter_content);

	formatter->call_name_map = malloc(sizeof(Map));
	make_map(formatter->call_name_map, hash_str, cmp_strs, (Destructor)dest_free_str);
	Pair ks[] = {
		{ "h1", "h1" },
		{ "h2", "h2" },
		{ "h3", "h3" },
		{ "h4", "h4" },
		{ "h5", "h5" },
		{ "h6", "h6" },
		{ "h1*", "h1" },
		{ "h2*", "h2" },
		{ "h3*", "h3" },
		{ "h4*", "h4" },
		{ "h5*", "h5" },
		{ "h6*", "h6" },
	};
	for (size_t i = 0; i < sizeof(ks) / sizeof(*ks); i++)
	{
		Maybe m;
		Str* k = malloc(sizeof(Str));
		make_strv(k, ks[i].p0);
		Str* v = malloc(sizeof(Str));
		make_strv(v, ks[i].p1);
		push_map(&m, formatter->call_name_map, k, v);
		dest_maybe(&m, NULL);
	}
}

static void dest_html_formatter(HtmlFormatter* formatter)
{
	dest_map(formatter->call_name_map, (Destructor)dest_free_str);
	free(formatter->call_name_map);
	dest_list(formatter->formatter_content, true, (Destructor)dest_free_str);
	free(formatter->formatter_content);
	dest_list(formatter->content, true, NULL);
	free(formatter->content);
	dest_str(formatter->output_doc_name);
	free(formatter->output_doc_name);
	dest_str(formatter->stylesheet_name);
	free(formatter->stylesheet_name);
	dest_str(formatter->time_str);
	free(formatter->time_str);
}

static int driver_runner(Doc* doc, DriverParams* params)
{
	int rc;
	HtmlFormatter formatter;
	make_html_formatter(&formatter, params);

	log_info("Outputting document to '%s'", formatter.output_doc_name->str);

	// Reformat the document and output it
	rc = format_doc_as_html(&formatter, doc);
	if (rc)
		return rc;
	rc = write_output(formatter.output_doc_name, formatter.content);
	if (rc)
		return rc;

	// Output the style file
	rc = output_stylesheet(&formatter, doc->styler->snippets);
	if (rc)
		return rc;

	dest_html_formatter(&formatter);
	return 0;
}

static int format_doc_as_html(HtmlFormatter* formatter, Doc* doc)
{
	append_strf(formatter, HTML_HEADER, formatter->time_str->str);
	append_raw(formatter, "<html>");
	append_raw(formatter, "\n<head>\n");
	append_strf(formatter, STYLESHEET_LINK, formatter->stylesheet_name->str);
	append_strf(formatter, TITLE_DEF, formatter->output_doc_name->str);
	/* append_raw(formatter, "<meta name=\"theme-color\" content=\"#2d2d2d\"/>"); */
	append_raw(formatter, "\n</head>");
	append_raw(formatter, "\n<body>\n");
	int rc = format_node_as_html(formatter, doc->root);
	if (rc)
		return rc;
	append_raw(formatter, "\n</body>");
	append_raw(formatter, "\n</html>");

	return 0;
}

static int format_node_as_html(HtmlFormatter* formatter, DocTreeNode* node)
{
	switch (node->content->type)
	{
		case WORD:
		{
			append_raw(formatter, " ");
			ListNode* ln = malloc(sizeof(ListNode));
			make_list_node(ln, node->content->word);
			append_list_node(formatter->content, ln);
			return 0;
		}
		case CALL:
		{
			Str* html_node_name;
			Maybe m;
			get_map(&m, formatter->call_name_map, node->name);
			switch (m.type)
			{
				case JUST:
					html_node_name = m.just;
					break;
				case NOTHING:
					html_node_name = malloc(sizeof(Str));
					make_strv(html_node_name, "span");
					ListNode* ln = malloc(sizeof(ListNode));
					make_list_node(ln, html_node_name);
					append_list_node(formatter->formatter_content, ln);
					break;
				default:
					log_err("Maybe object has unknown data constructor: %d", m.type);
					return 1;
			}
			int rc = 0;
			if (node->content->call_params->result)
			{
				append_strf(formatter, "<%s class=\"%s\">", html_node_name->str, node->name->str);
				rc = format_node_as_html(formatter, node->content->call_params->result);
				append_strf(formatter, "</%s>", html_node_name->str);
			}
			dest_maybe(&m, NULL);
			return rc;
		}
		case LINE:
			return format_node_list_as_html(formatter, node->content->line);
		case LINES:
			return format_node_list_as_html(formatter, node->content->lines);
		case PAR:
			append_raw(formatter, "<p>");
			int rc = format_node_list_as_html(formatter, node->content->par);
			append_raw(formatter, "</p>");
			return rc;
		case PARS:
			return format_node_list_as_html(formatter, node->content->pars);
		default:
			log_err("Unknown node content type: %d", node->content->type);
			return 1;
	}
	return 0;
}

static int format_node_list_as_html(HtmlFormatter* formatter, List* node_list)
{
	int rc = 0;

	ListIter li;
	make_list_iter(&li, node_list);
	DocTreeNode* node;
	while (iter_list((void**)&node, &li))
	{
		rc = format_node_as_html(formatter, node);
		if (rc)
			break;
	}
	dest_list_iter(&li);
	return rc;
}

static void append_raw(HtmlFormatter* formatter, char* raw)
{
	Str* str = malloc(sizeof(Str));
	make_strv(str, raw);
	append_str(formatter, str);
}

static void append_str(HtmlFormatter* formatter, Str* str)
{
	ListNode* ln = malloc(sizeof(ListNode));
	make_list_node(ln, str);
	append_list_node(formatter->content, ln);
	ListNode* ln2 = malloc(sizeof(ListNode));
	make_list_node(ln2, str);
	append_list_node(formatter->formatter_content, ln2);
}

static void append_strf(HtmlFormatter* formatter, char* restrict format, ...)
{
	va_list va;
	va_list va2;
	va_start(va, format);
	va_copy(va2, va);
	size_t maxlen = 1 + vsnprintf(NULL, 0, format, va); // NOLINT
	Str* str	  = malloc(sizeof(Str));
	char* raw	  = malloc(maxlen * sizeof(char));
	vsnprintf(raw, maxlen, format, va2);
	make_strr(str, raw);
	ListNode* ln = malloc(sizeof(ListNode));
	make_list_node(ln, str);
	append_list_node(formatter->content, ln);
	ListNode* ln2 = malloc(sizeof(ListNode));
	make_list_node(ln2, str);
	append_list_node(formatter->formatter_content, ln2);
	va_end(va2);
	va_end(va);
}

static int output_stylesheet(HtmlFormatter* formatter, List* css_snippets)
{
	log_info("Outputting stylesheet to '%s'", formatter->stylesheet_name->str);

	// Add the header to the css
	ListNode* ln		 = malloc(sizeof(ListNode));
	size_t header_len	 = 1 + snprintf(NULL, 0, STYLESHEET_HEADER, formatter->time_str->str);
	char* header_content = malloc(header_len);
	snprintf(header_content, header_len, STYLESHEET_HEADER, formatter->time_str->str);
	Str* header_str = malloc(sizeof(Str));
	make_strr(header_str, header_content);
	make_list_node(ln, header_str);
	prepend_list_node(css_snippets, ln);

	return write_output(formatter->stylesheet_name, css_snippets);
}

#define TIME_STR_MAX_SUPPORTED_SIZE 26
static void get_time_str(Str* time_str)
{
	time_t curr_time;
	time(&curr_time);
	char* time_buf		 = malloc(TIME_STR_MAX_SUPPORTED_SIZE * sizeof(char));
	struct tm* time_info = localtime(&curr_time);
	asctime_r(time_info, time_buf);
	time_buf[strlen(time_buf) - 1] = '\0'; // Strip trailing newline

	make_strr(time_str, time_buf);
}
